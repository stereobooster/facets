# Inverted index experiment

## TODO

- workspace
  - main package
    - MVP
      - [ ] facets
        - I don't need text search pagination in order to build all facets intersection
        - it takes `n!` intersections, but only if there is more than one facet or text search
        - I need to intersect only selected value plus enough for the first page
      - [ ] sort results by relevance
      - [ ] filter by callback (for numeric ranges)
      - [ ] function to fetch more facets data (pagination)
    - Post MVP
      - typescript signature
      - mapPaginate - function to map item only enough to fill current page
      - search for facets
      - built-in prefix search based on TrieMap
        - through facet filter
      - memoization for consequent operations
        - search narrowing
        - pagination
        - sorting
      - filter by facet by numeric range
        - would allow better memoization
      - sort by more than one column
      - highilght search results
      - event dispatcher to allow async loading, async indexing
        - https://github.com/developit/mitt
      - web worker
      - date time columns
      - more than one level objects
    - Other
      - [BFloat16 wasm](https://github.com/tc39/proposal-float16array/issues/7)
      - RoaringWasm and other TrieMaps
      - hierarchical filter with TrieMap and custom separator (`/` instead of `>`)
        - But it needs a way to get root level keys
      - preindexed data
  - InstantSearch adpater
    - https://github.com/unplatform-io/instantsearch-itemsjs-adapter/blob/main/src/adapter.ts
    - https://github.com/typesense/typesense-instantsearch-adapter/blob/master/src/TypesenseInstantsearchAdapter.js
  - demo with table / cards
  - query string parser
  - demo with graph?
  - alternative solutions
    - test CSV instead of JSON (memory footprint)
    - memoize sort order in `TypedArray` (Int16)
